- Write a crapton of examples for `doctest` to test!
- Document everything
- Handle all of the sections marked "TODO" in the code
- Methods to add:
 - convert from a list of byte values with control over bit order
 - convert to & from integers with control over endianness and bit order
   (cf. Python 3's `int.to_bytes`)
 - convert to & from byte strings with control over bit order
 - convert to & from strings of '0' and '1'?
 - convert to & from sequences of ints with control over int size, endianness,
   and bit order
 - right-shifting with an option to keep the size the same?
 - right-shifting with sign extension?
 - left-shift, filling with 1's?
 - rotationally-shifting the bits
 - shifting while preserving width?
 - number of set & unset bits (cf. count)
 - `lstrip` - trim zeroes from the "top"
 - `strip` - trim zeroes from both sides
 - set/unset all bits?
  - Make `bitvec[a:b] = boolean` set/unset all bits in the slice?
 - one's and two's complement?
 - "any", "all", and "none"?
 - reverse the bit order in-place?
 - test for subsetness?
 - something similar to Perl's `vec` that sets the bits of a subvector so
   that they equal a specified integer value but without changing any
   lengths; cf. the __setitem__ behavior when assigning an integer to a slice
- Follow the instructions at <https://docs.python.org/2/distutils/index.html>
- Make `toBytes` (and future methods with configurable bit order) take the bit
  order as a boolean `bits_ascending` (or `bits_descending`?) keyword argument
  instead of as a string
- Rethink how `fromSetBits` handles negative indices
- Abstract away the references to the elements of _blob being 8 bits so that
  the sizes of the elements can be easily changed
- Should __cmp__ compare bitvectors as though they were integers, i.e., with
  the most significant (highest-index) bits compared first?
- Support Python 3
